@file:Suppress("RedundantVisibilityModifier")

package com.labijie.application.identity.`data`.pojo.dsl

import com.labijie.application.identity.`data`.RoleClaimTable
import com.labijie.application.identity.`data`.RoleClaimTable.claimType
import com.labijie.application.identity.`data`.RoleClaimTable.claimValue
import com.labijie.application.identity.`data`.RoleClaimTable.id
import com.labijie.application.identity.`data`.RoleClaimTable.roleId
import com.labijie.application.identity.`data`.pojo.RoleClaim
import com.labijie.infra.orm.OffsetList
import java.lang.IllegalArgumentException
import kotlin.Array
import kotlin.Boolean
import kotlin.Comparable
import kotlin.Int
import kotlin.Long
import kotlin.Number
import kotlin.String
import kotlin.Unit
import kotlin.collections.Collection
import kotlin.collections.Iterable
import kotlin.collections.List
import kotlin.collections.isNotEmpty
import kotlin.collections.last
import kotlin.collections.toList
import kotlin.reflect.KClass
import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.Op
import org.jetbrains.exposed.sql.Query
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SortOrder
import org.jetbrains.exposed.sql.SqlExpressionBuilder
import org.jetbrains.exposed.sql.SqlExpressionBuilder.eq
import org.jetbrains.exposed.sql.and
import org.jetbrains.exposed.sql.andWhere
import org.jetbrains.exposed.sql.batchInsert
import org.jetbrains.exposed.sql.batchUpsert
import org.jetbrains.exposed.sql.deleteWhere
import org.jetbrains.exposed.sql.insert
import org.jetbrains.exposed.sql.insertIgnore
import org.jetbrains.exposed.sql.orWhere
import org.jetbrains.exposed.sql.replace
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.statements.InsertStatement
import org.jetbrains.exposed.sql.statements.ReplaceStatement
import org.jetbrains.exposed.sql.statements.UpdateBuilder
import org.jetbrains.exposed.sql.statements.UpdateStatement
import org.jetbrains.exposed.sql.statements.UpsertBuilder
import org.jetbrains.exposed.sql.statements.UpsertStatement
import org.jetbrains.exposed.sql.update
import org.jetbrains.exposed.sql.upsert

/**
 * DSL support for RoleClaimTable
 *
 * This code generated by an open-source project: Infra-Orm 
 * Project Site: https://github.com/hongque-pro/infra-orm.
 *
 * Generator Version: 2.1.1
 *
 *
 * Don't modify these codes !!
 *
 * Origin Exposed Table:
 * @see com.labijie.application.identity.data.RoleClaimTable
 */
@kotlin.Suppress(
  "unused",
  "DuplicatedCode",
  "MemberVisibilityCanBePrivate",
  "RemoveRedundantQualifierName",
)
public object RoleClaimDSL {
  public val RoleClaimTable.allColumns: Array<Column<*>> by lazy {
    arrayOf(
    claimType,
    claimValue,
    roleId,
    id,
    )
  }

  public fun parseRow(raw: ResultRow): RoleClaim {
    val plain = RoleClaim()
    plain.claimType = raw[claimType]
    plain.claimValue = raw[claimValue]
    plain.roleId = raw[roleId]
    plain.id = raw[id]
    return plain
  }

  public fun parseRowSelective(row: ResultRow): RoleClaim {
    val plain = RoleClaim()
    if(row.hasValue(claimType)) {
      plain.claimType = row[claimType]
    }
    if(row.hasValue(claimValue)) {
      plain.claimValue = row[claimValue]
    }
    if(row.hasValue(roleId)) {
      plain.roleId = row[roleId]
    }
    if(row.hasValue(id)) {
      plain.id = row[id]
    }
    return plain
  }

  public fun <T> RoleClaimTable.getColumnType(column: Column<T>): KClass<*> = when(column) {
    claimType->String::class
    claimValue->String::class
    roleId->Long::class
    id->Long::class
    else->throw IllegalArgumentException("""Unknown column <${column.name}> for 'RoleClaim'""")
  }

  private fun <T> RoleClaim.getColumnValueString(column: Column<T>): String = when(column) {
    RoleClaimTable.claimType->this.claimType
    RoleClaimTable.claimValue->this.claimValue
    RoleClaimTable.roleId -> this.roleId.toString()

    RoleClaimTable.id -> this.id.toString()

    else->throw IllegalArgumentException("""Can't converter value of RoleClaim::${column.name} to string.""")
  }

  @kotlin.Suppress("UNCHECKED_CAST")
  private fun <T> parseColumnValue(valueString: String, column: Column<T>): T {
    val value = when(column) {
      RoleClaimTable.claimType -> valueString
      RoleClaimTable.claimValue -> valueString
      RoleClaimTable.roleId ->valueString.toLong()
      RoleClaimTable.id ->valueString.toLong()
      else->throw IllegalArgumentException("""Can't converter value of RoleClaim::${column.name} to string.""")
    }
    return value as T
  }

  @kotlin.Suppress("UNCHECKED_CAST")
  public fun <T> RoleClaim.getColumnValue(column: Column<T>): T = when(column) {
    RoleClaimTable.claimType->this.claimType as T
    RoleClaimTable.claimValue->this.claimValue as T
    RoleClaimTable.roleId->this.roleId as T
    RoleClaimTable.id->this.id as T
    else->throw IllegalArgumentException("""Unknown column <${column.name}> for 'RoleClaim'""")
  }

  public fun assign(
    builder: UpdateBuilder<*>,
    raw: RoleClaim,
    selective: Array<out Column<*>>? = null,
    vararg ignore: Column<*>,
  ) {
    val list = if(selective.isNullOrEmpty()) null else selective
    if((list == null || list.contains(claimType)) && !ignore.contains(claimType))
      builder[claimType] = raw.claimType
    if((list == null || list.contains(claimValue)) && !ignore.contains(claimValue))
      builder[claimValue] = raw.claimValue
    if((list == null || list.contains(roleId)) && !ignore.contains(roleId))
      builder[roleId] = raw.roleId
    if((list == null || list.contains(id)) && !ignore.contains(id))
      builder[id] = raw.id
  }

  public fun ResultRow.toRoleClaim(vararg selective: Column<*>): RoleClaim {
    if(selective.isNotEmpty()) {
      return parseRowSelective(this)
    }
    return parseRow(this)
  }

  public fun Iterable<ResultRow>.toRoleClaimList(vararg selective: Column<*>): List<RoleClaim> = this.map {
    it.toRoleClaim(*selective)
  }

  public fun RoleClaimTable.selectSlice(vararg selective: Column<*>): Query {
    val query = if(selective.isNotEmpty()) {
      select(selective.toList())
    }
    else {
      selectAll()
    }
    return query
  }

  public fun UpdateBuilder<*>.setValue(raw: RoleClaim, vararg ignore: Column<*>): Unit = assign(this, raw, ignore = ignore)

  public fun UpdateBuilder<*>.setValueSelective(raw: RoleClaim, vararg selective: Column<*>): Unit = assign(this, raw, selective = selective)

  public fun RoleClaimTable.insert(raw: RoleClaim): InsertStatement<Number> = insert {
    assign(it, raw)
  }

  public fun RoleClaimTable.insertIgnore(raw: RoleClaim): InsertStatement<Long> = insertIgnore {
    assign(it, raw)
  }

  public fun RoleClaimTable.upsert(
    raw: RoleClaim,
    onUpdateExclude: List<Column<*>>? = null,
    onUpdate: (UpsertBuilder.(UpdateStatement) -> Unit)? = null,
    `where`: (SqlExpressionBuilder.() -> Op<Boolean>)? = null,
  ): UpsertStatement<Long> = upsert(where = where, onUpdate = onUpdate, onUpdateExclude = onUpdateExclude) {
    assign(it, raw)
  }

  public fun RoleClaimTable.batchInsert(
    list: Iterable<RoleClaim>,
    ignoreErrors: Boolean = false,
    shouldReturnGeneratedValues: Boolean = false,
  ): List<ResultRow> {
    val rows = batchInsert(list, ignoreErrors, shouldReturnGeneratedValues) {
      entry -> assign(this, entry)
    }
    return rows
  }

  public fun RoleClaimTable.batchUpsert(
    list: Iterable<RoleClaim>,
    onUpdateExclude: List<Column<*>>? = null,
    onUpdate: (UpsertBuilder.(UpdateStatement) -> Unit)? = null,
    shouldReturnGeneratedValues: Boolean = false,
    `where`: (SqlExpressionBuilder.() -> Op<Boolean>)? = null,
  ): List<ResultRow> {
    val rows =  batchUpsert(data = list, keys = arrayOf(id), onUpdate = onUpdate, onUpdateExclude = onUpdateExclude, where = where, shouldReturnGeneratedValues = shouldReturnGeneratedValues) {
      data: RoleClaim-> assign(this, data)
    }
    return rows
  }

  public fun RoleClaimTable.update(
    raw: RoleClaim,
    selective: Array<out Column<*>>? = null,
    ignore: Array<out Column<*>>? = null,
    limit: Int? = null,
    `where`: SqlExpressionBuilder.() -> Op<Boolean>,
  ): Int = update(`where`, limit) {
    val ignoreColumns = ignore ?: arrayOf()
    assign(it, raw, selective = selective, *ignoreColumns)
  }

  public fun RoleClaimTable.updateByPrimaryKey(raw: RoleClaim, vararg selective: Column<*>): Int = update(raw, selective = selective, ignore = arrayOf(id)) {
    RoleClaimTable.id.eq(raw.id)
  }

  public fun RoleClaimTable.updateByPrimaryKey(id: Long, builder: RoleClaimTable.(UpdateStatement) -> Unit): Int = update({ RoleClaimTable.id.eq(id) }, body = builder)

  public fun RoleClaimTable.deleteByPrimaryKey(id: Long): Int = deleteWhere {
    RoleClaimTable.id.eq(id)
  }

  public fun RoleClaimTable.selectByPrimaryKey(id: Long, vararg selective: Column<*>): RoleClaim? {
    val query = selectSlice(*selective).andWhere {
      RoleClaimTable.id.eq(id)
    }
    return query.firstOrNull()?.toRoleClaim(*selective)
  }

  public fun RoleClaimTable.selectByPrimaryKeys(ids: Iterable<Long>, vararg selective: Column<*>): List<RoleClaim> {
    val query = selectSlice(*selective).andWhere {
      RoleClaimTable.id inList ids
    }
    return query.toRoleClaimList(*selective)
  }

  public fun RoleClaimTable.selectMany(vararg selective: Column<*>, `where`: Query.() -> Query?): List<RoleClaim> {
    val query = selectSlice(*selective)
    `where`.invoke(query)
    return query.toRoleClaimList(*selective)
  }

  public fun RoleClaimTable.selectOne(vararg selective: Column<*>, `where`: Query.() -> Query?): RoleClaim? {
    val query = selectSlice(*selective)
    `where`.invoke(query)
    return query.firstOrNull()?.toRoleClaim(*selective)
  }

  public fun RoleClaimTable.selectForwardByPrimaryKey(
    forwardToken: String? = null,
    order: SortOrder = SortOrder.DESC,
    pageSize: Int = 50,
    selective: Collection<Column<*>> = listOf(),
    `where`: (Query.() -> Query?)? = null,
  ): OffsetList<RoleClaim> {
    if(pageSize < 1) {
      return OffsetList.empty()
    }
    val offsetKey = forwardToken?.let { OffsetList.decodeToken(it).firstOrNull()?.ifBlank { null } }
    val query = selectSlice(*selective.toTypedArray())
    offsetKey?.let {
      val keyValue = parseColumnValue(it, id)
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.andWhere { id less keyValue }
        else-> query.andWhere { id greater keyValue }
      }
    }
    `where`?.invoke(query)
    val sorted = query.orderBy(id, order)
    val list = sorted.limit(pageSize + 1).toRoleClaimList(*selective.toTypedArray()).toMutableList()
    val dataCount = list.size
    val token = if(dataCount > pageSize) {
      list.removeLast()
      val idString = list.last().getColumnValueString(id)
      OffsetList.encodeToken(idString)
    }
    else {
      null
    }
    return OffsetList(list, token)
  }

  public fun <T : Comparable<T>> RoleClaimTable.selectForward(
    sortColumn: Column<T>,
    forwardToken: String? = null,
    order: SortOrder = SortOrder.DESC,
    pageSize: Int = 50,
    selective: Collection<Column<*>> = listOf(),
    `where`: (Query.() -> Query?)? = null,
  ): OffsetList<RoleClaim> {
    if(pageSize < 1) {
      return OffsetList.empty()
    }
    if(sortColumn == id) {
      return this.selectForwardByPrimaryKey(forwardToken, order, pageSize, selective, `where`)
    }
    val kp = forwardToken?.let { if(it.isNotBlank()) OffsetList.decodeToken(it) else null }
    val offsetKey = if(!kp.isNullOrEmpty()) parseColumnValue(kp.first(), sortColumn) else null
    val lastId = if(kp != null && kp.size > 1 && kp[1].isNotBlank()) parseColumnValue(kp[1], id) else null
    val query = selectSlice(*selective.toTypedArray())
    offsetKey?.let {
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.andWhere { sortColumn less it }
        else-> query.andWhere { sortColumn greater it }
      }
    }
    if(lastId != null && offsetKey != null) {
      when(order) {
        SortOrder.DESC, SortOrder.DESC_NULLS_FIRST, SortOrder.DESC_NULLS_LAST->
        query.orWhere { sortColumn.eq(offsetKey) and id.less(lastId) }
        else-> query.orWhere { sortColumn.eq(offsetKey) and id.greater(lastId) }
      }
    }
    `where`?.invoke(query)
    val sorted = query.orderBy(Pair(sortColumn, order), Pair(id, order))
    val list = sorted.limit(pageSize + 1).toRoleClaimList(*selective.toTypedArray()).toMutableList()
    val dataCount = list.size
    val token = if(dataCount > pageSize) {
      list.removeLast()
      val idToEncode = list.last().getColumnValueString(id)
      val sortKey = list.last().getColumnValueString(sortColumn)
      OffsetList.encodeToken(arrayOf(sortKey, idToEncode))
    }
    else null
    return OffsetList(list, token)
  }

  public fun RoleClaimTable.replace(raw: RoleClaim): ReplaceStatement<Long> = replace {
    assign(it, raw)
  }
}
