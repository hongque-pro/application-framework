@file:Suppress("RedundantVisibilityModifier")

package com.labijie.application.identity.`data`.pojo.dsl

import com.labijie.application.identity.`data`.OAuth2ClientTable
import com.labijie.application.identity.`data`.OAuth2ClientTable.accessTokenLiveSeconds
import com.labijie.application.identity.`data`.OAuth2ClientTable.additionalInformation
import com.labijie.application.identity.`data`.OAuth2ClientTable.authorities
import com.labijie.application.identity.`data`.OAuth2ClientTable.authorizationCodeLiveSeconds
import com.labijie.application.identity.`data`.OAuth2ClientTable.authorizedGrantTypes
import com.labijie.application.identity.`data`.OAuth2ClientTable.autoApprove
import com.labijie.application.identity.`data`.OAuth2ClientTable.clientId
import com.labijie.application.identity.`data`.OAuth2ClientTable.clientSecret
import com.labijie.application.identity.`data`.OAuth2ClientTable.deviceCodeLiveSeconds
import com.labijie.application.identity.`data`.OAuth2ClientTable.enabled
import com.labijie.application.identity.`data`.OAuth2ClientTable.redirectUrls
import com.labijie.application.identity.`data`.OAuth2ClientTable.refreshTokenLiveSeconds
import com.labijie.application.identity.`data`.OAuth2ClientTable.resourceIds
import com.labijie.application.identity.`data`.OAuth2ClientTable.reuseRefreshTokens
import com.labijie.application.identity.`data`.OAuth2ClientTable.scopes
import com.labijie.application.identity.`data`.pojo.OAuth2Client
import java.lang.IllegalArgumentException
import kotlin.Array
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.Number
import kotlin.String
import kotlin.Unit
import kotlin.collections.Iterable
import kotlin.collections.List
import kotlin.collections.isNotEmpty
import kotlin.collections.toList
import kotlin.reflect.KClass
import org.jetbrains.exposed.sql.Column
import org.jetbrains.exposed.sql.Op
import org.jetbrains.exposed.sql.Query
import org.jetbrains.exposed.sql.ResultRow
import org.jetbrains.exposed.sql.SqlExpressionBuilder
import org.jetbrains.exposed.sql.batchInsert
import org.jetbrains.exposed.sql.batchUpsert
import org.jetbrains.exposed.sql.insert
import org.jetbrains.exposed.sql.insertIgnore
import org.jetbrains.exposed.sql.replace
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.statements.InsertStatement
import org.jetbrains.exposed.sql.statements.ReplaceStatement
import org.jetbrains.exposed.sql.statements.UpdateBuilder
import org.jetbrains.exposed.sql.statements.UpdateStatement
import org.jetbrains.exposed.sql.statements.UpsertBuilder
import org.jetbrains.exposed.sql.statements.UpsertStatement
import org.jetbrains.exposed.sql.update
import org.jetbrains.exposed.sql.upsert

/**
 * DSL support for OAuth2ClientTable
 *
 * This code generated by an open-source project: Infra-Orm 
 * Project Site: https://github.com/hongque-pro/infra-orm.
 * Generator Version: 2.0.10
 *
 *
 * Don't modify these codes !!
 *
 * Origin Exposed Table:
 * @see com.labijie.application.identity.data.OAuth2ClientTable
 */
@kotlin.Suppress(
  "unused",
  "DuplicatedCode",
  "MemberVisibilityCanBePrivate",
  "RemoveRedundantQualifierName",
)
public object OAuth2ClientDSL {
  public val OAuth2ClientTable.allColumns: Array<Column<*>> by lazy {
    arrayOf(
    clientId,
    resourceIds,
    clientSecret,
    scopes,
    authorizedGrantTypes,
    redirectUrls,
    authorities,
    additionalInformation,
    autoApprove,
    enabled,
    accessTokenLiveSeconds,
    refreshTokenLiveSeconds,
    authorizationCodeLiveSeconds,
    deviceCodeLiveSeconds,
    reuseRefreshTokens,
    )
  }

  public fun parseRow(raw: ResultRow): OAuth2Client {
    val plain = OAuth2Client()
    plain.clientId = raw[clientId]
    plain.resourceIds = raw[resourceIds]
    plain.clientSecret = raw[clientSecret]
    plain.scopes = raw[scopes]
    plain.authorizedGrantTypes = raw[authorizedGrantTypes]
    plain.redirectUrls = raw[redirectUrls]
    plain.authorities = raw[authorities]
    plain.additionalInformation = raw[additionalInformation]
    plain.autoApprove = raw[autoApprove]
    plain.enabled = raw[enabled]
    plain.accessTokenLiveSeconds = raw[accessTokenLiveSeconds]
    plain.refreshTokenLiveSeconds = raw[refreshTokenLiveSeconds]
    plain.authorizationCodeLiveSeconds = raw[authorizationCodeLiveSeconds]
    plain.deviceCodeLiveSeconds = raw[deviceCodeLiveSeconds]
    plain.reuseRefreshTokens = raw[reuseRefreshTokens]
    return plain
  }

  public fun parseRowSelective(row: ResultRow): OAuth2Client {
    val plain = OAuth2Client()
    if(row.hasValue(clientId)) {
      plain.clientId = row[clientId]
    }
    if(row.hasValue(resourceIds)) {
      plain.resourceIds = row[resourceIds]
    }
    if(row.hasValue(clientSecret)) {
      plain.clientSecret = row[clientSecret]
    }
    if(row.hasValue(scopes)) {
      plain.scopes = row[scopes]
    }
    if(row.hasValue(authorizedGrantTypes)) {
      plain.authorizedGrantTypes = row[authorizedGrantTypes]
    }
    if(row.hasValue(redirectUrls)) {
      plain.redirectUrls = row[redirectUrls]
    }
    if(row.hasValue(authorities)) {
      plain.authorities = row[authorities]
    }
    if(row.hasValue(additionalInformation)) {
      plain.additionalInformation = row[additionalInformation]
    }
    if(row.hasValue(autoApprove)) {
      plain.autoApprove = row[autoApprove]
    }
    if(row.hasValue(enabled)) {
      plain.enabled = row[enabled]
    }
    if(row.hasValue(accessTokenLiveSeconds)) {
      plain.accessTokenLiveSeconds = row[accessTokenLiveSeconds]
    }
    if(row.hasValue(refreshTokenLiveSeconds)) {
      plain.refreshTokenLiveSeconds = row[refreshTokenLiveSeconds]
    }
    if(row.hasValue(authorizationCodeLiveSeconds)) {
      plain.authorizationCodeLiveSeconds = row[authorizationCodeLiveSeconds]
    }
    if(row.hasValue(deviceCodeLiveSeconds)) {
      plain.deviceCodeLiveSeconds = row[deviceCodeLiveSeconds]
    }
    if(row.hasValue(reuseRefreshTokens)) {
      plain.reuseRefreshTokens = row[reuseRefreshTokens]
    }
    return plain
  }

  public fun <T> OAuth2ClientTable.getColumnType(column: Column<T>): KClass<*> = when(column) {
    clientId->String::class
    resourceIds->String::class
    clientSecret->String::class
    scopes->String::class
    authorizedGrantTypes->String::class
    redirectUrls->String::class
    authorities->String::class
    additionalInformation->String::class
    autoApprove->Boolean::class
    enabled->Boolean::class
    accessTokenLiveSeconds->Int::class
    refreshTokenLiveSeconds->Int::class
    authorizationCodeLiveSeconds->Int::class
    deviceCodeLiveSeconds->Int::class
    reuseRefreshTokens->Boolean::class
    else->throw IllegalArgumentException("""Unknown column <${column.name}> for 'OAuth2Client'""")
  }

  private fun <T> OAuth2Client.getColumnValueString(column: Column<T>): String = when(column) {
    OAuth2ClientTable.clientId->this.clientId
    OAuth2ClientTable.resourceIds->this.resourceIds
    OAuth2ClientTable.clientSecret->this.clientSecret
    OAuth2ClientTable.scopes->this.scopes
    OAuth2ClientTable.authorizedGrantTypes->this.authorizedGrantTypes
    OAuth2ClientTable.redirectUrls->this.redirectUrls
    OAuth2ClientTable.authorities->this.authorities
    OAuth2ClientTable.additionalInformation->this.additionalInformation
    OAuth2ClientTable.autoApprove->this.autoApprove.toString()

    OAuth2ClientTable.enabled->this.enabled.toString()

    OAuth2ClientTable.accessTokenLiveSeconds->this.accessTokenLiveSeconds.toString()

    OAuth2ClientTable.refreshTokenLiveSeconds->this.refreshTokenLiveSeconds.toString()

    OAuth2ClientTable.authorizationCodeLiveSeconds->this.authorizationCodeLiveSeconds.toString()

    OAuth2ClientTable.deviceCodeLiveSeconds->this.deviceCodeLiveSeconds.toString()

    OAuth2ClientTable.reuseRefreshTokens->this.reuseRefreshTokens.toString()

    else->throw
        IllegalArgumentException("""Can't converter value of OAuth2Client::${column.name} to string.""")
  }

  @kotlin.Suppress("UNCHECKED_CAST")
  private fun <T> parseColumnValue(valueString: String, column: Column<T>): T {
    val value = when(column) {
      OAuth2ClientTable.clientId -> valueString
      OAuth2ClientTable.resourceIds -> valueString
      OAuth2ClientTable.clientSecret -> valueString
      OAuth2ClientTable.scopes -> valueString
      OAuth2ClientTable.authorizedGrantTypes -> valueString
      OAuth2ClientTable.redirectUrls -> valueString
      OAuth2ClientTable.authorities -> valueString
      OAuth2ClientTable.additionalInformation -> valueString
      OAuth2ClientTable.autoApprove ->valueString.toBoolean()
      OAuth2ClientTable.enabled ->valueString.toBoolean()
      OAuth2ClientTable.accessTokenLiveSeconds ->valueString.toInt()
      OAuth2ClientTable.refreshTokenLiveSeconds ->valueString.toInt()
      OAuth2ClientTable.authorizationCodeLiveSeconds ->valueString.toInt()
      OAuth2ClientTable.deviceCodeLiveSeconds ->valueString.toInt()
      OAuth2ClientTable.reuseRefreshTokens ->valueString.toBoolean()
      else->throw
          IllegalArgumentException("""Can't converter value of OAuth2Client::${column.name} to string.""")
    }
    return value as T
  }

  @kotlin.Suppress("UNCHECKED_CAST")
  public fun <T> OAuth2Client.getColumnValue(column: Column<T>): T = when(column) {
    OAuth2ClientTable.clientId->this.clientId as T
    OAuth2ClientTable.resourceIds->this.resourceIds as T
    OAuth2ClientTable.clientSecret->this.clientSecret as T
    OAuth2ClientTable.scopes->this.scopes as T
    OAuth2ClientTable.authorizedGrantTypes->this.authorizedGrantTypes as T
    OAuth2ClientTable.redirectUrls->this.redirectUrls as T
    OAuth2ClientTable.authorities->this.authorities as T
    OAuth2ClientTable.additionalInformation->this.additionalInformation as T
    OAuth2ClientTable.autoApprove->this.autoApprove as T
    OAuth2ClientTable.enabled->this.enabled as T
    OAuth2ClientTable.accessTokenLiveSeconds->this.accessTokenLiveSeconds as T
    OAuth2ClientTable.refreshTokenLiveSeconds->this.refreshTokenLiveSeconds as T
    OAuth2ClientTable.authorizationCodeLiveSeconds->this.authorizationCodeLiveSeconds as T
    OAuth2ClientTable.deviceCodeLiveSeconds->this.deviceCodeLiveSeconds as T
    OAuth2ClientTable.reuseRefreshTokens->this.reuseRefreshTokens as T
    else->throw IllegalArgumentException("""Unknown column <${column.name}> for 'OAuth2Client'""")
  }

  public fun assign(
    builder: UpdateBuilder<*>,
    raw: OAuth2Client,
    selective: Array<out Column<*>>? = null,
    vararg ignore: Column<*>,
  ) {
    val list = if(selective.isNullOrEmpty()) null else selective
    if((list == null || list.contains(clientId)) && !ignore.contains(clientId))
      builder[clientId] = raw.clientId
    if((list == null || list.contains(resourceIds)) && !ignore.contains(resourceIds))
      builder[resourceIds] = raw.resourceIds
    if((list == null || list.contains(clientSecret)) && !ignore.contains(clientSecret))
      builder[clientSecret] = raw.clientSecret
    if((list == null || list.contains(scopes)) && !ignore.contains(scopes))
      builder[scopes] = raw.scopes
    if((list == null || list.contains(authorizedGrantTypes)) &&
        !ignore.contains(authorizedGrantTypes))
      builder[authorizedGrantTypes] = raw.authorizedGrantTypes
    if((list == null || list.contains(redirectUrls)) && !ignore.contains(redirectUrls))
      builder[redirectUrls] = raw.redirectUrls
    if((list == null || list.contains(authorities)) && !ignore.contains(authorities))
      builder[authorities] = raw.authorities
    if((list == null || list.contains(additionalInformation)) &&
        !ignore.contains(additionalInformation))
      builder[additionalInformation] = raw.additionalInformation
    if((list == null || list.contains(autoApprove)) && !ignore.contains(autoApprove))
      builder[autoApprove] = raw.autoApprove
    if((list == null || list.contains(enabled)) && !ignore.contains(enabled))
      builder[enabled] = raw.enabled
    if((list == null || list.contains(accessTokenLiveSeconds)) &&
        !ignore.contains(accessTokenLiveSeconds))
      builder[accessTokenLiveSeconds] = raw.accessTokenLiveSeconds
    if((list == null || list.contains(refreshTokenLiveSeconds)) &&
        !ignore.contains(refreshTokenLiveSeconds))
      builder[refreshTokenLiveSeconds] = raw.refreshTokenLiveSeconds
    if((list == null || list.contains(authorizationCodeLiveSeconds)) &&
        !ignore.contains(authorizationCodeLiveSeconds))
      builder[authorizationCodeLiveSeconds] = raw.authorizationCodeLiveSeconds
    if((list == null || list.contains(deviceCodeLiveSeconds)) &&
        !ignore.contains(deviceCodeLiveSeconds))
      builder[deviceCodeLiveSeconds] = raw.deviceCodeLiveSeconds
    if((list == null || list.contains(reuseRefreshTokens)) && !ignore.contains(reuseRefreshTokens))
      builder[reuseRefreshTokens] = raw.reuseRefreshTokens
  }

  public fun ResultRow.toOAuth2Client(vararg selective: Column<*>): OAuth2Client {
    if(selective.isNotEmpty()) {
      return parseRowSelective(this)
    }
    return parseRow(this)
  }

  public fun Iterable<ResultRow>.toOAuth2ClientList(vararg selective: Column<*>): List<OAuth2Client>
      = this.map {
    it.toOAuth2Client(*selective)
  }

  public fun OAuth2ClientTable.selectSlice(vararg selective: Column<*>): Query {
    val query = if(selective.isNotEmpty()) {
      select(selective.toList())
    }
    else {
      selectAll()
    }
    return query
  }

  public fun UpdateBuilder<*>.setValue(raw: OAuth2Client, vararg ignore: Column<*>): Unit =
      assign(this, raw, ignore = ignore)

  public fun UpdateBuilder<*>.setValueSelective(raw: OAuth2Client, vararg selective: Column<*>):
      Unit = assign(this, raw, selective = selective)

  public fun OAuth2ClientTable.insert(raw: OAuth2Client): InsertStatement<Number> = insert {
    assign(it, raw)
  }

  public fun OAuth2ClientTable.insertIgnore(raw: OAuth2Client): InsertStatement<Long> =
      insertIgnore {
    assign(it, raw)
  }

  public fun OAuth2ClientTable.upsert(
    raw: OAuth2Client,
    onUpdateExclude: List<Column<*>>? = null,
    onUpdate: (UpsertBuilder.(UpdateStatement) -> Unit)? = null,
    `where`: (SqlExpressionBuilder.() -> Op<Boolean>)? = null,
  ): UpsertStatement<Long> = upsert(where = where, onUpdate = onUpdate, onUpdateExclude =
      onUpdateExclude) {
    assign(it, raw)
  }

  public fun OAuth2ClientTable.batchInsert(
    list: Iterable<OAuth2Client>,
    ignoreErrors: Boolean = false,
    shouldReturnGeneratedValues: Boolean = false,
  ): List<ResultRow> {
    val rows = batchInsert(list, ignoreErrors, shouldReturnGeneratedValues) {
      entry -> assign(this, entry)
    }
    return rows
  }

  public fun OAuth2ClientTable.batchUpsert(
    list: Iterable<OAuth2Client>,
    onUpdateExclude: List<Column<*>>? = null,
    onUpdate: (UpsertBuilder.(UpdateStatement) -> Unit)? = null,
    shouldReturnGeneratedValues: Boolean = false,
    `where`: (SqlExpressionBuilder.() -> Op<Boolean>)? = null,
  ): List<ResultRow> {
    val rows =  batchUpsert(data = list, keys = arrayOf(), onUpdate = onUpdate, onUpdateExclude =
        onUpdateExclude, where = where, shouldReturnGeneratedValues = shouldReturnGeneratedValues) {
      data: OAuth2Client-> assign(this, data)
    }
    return rows
  }

  public fun OAuth2ClientTable.update(
    raw: OAuth2Client,
    selective: Array<out Column<*>>? = null,
    ignore: Array<out Column<*>>? = null,
    limit: Int? = null,
    `where`: SqlExpressionBuilder.() -> Op<Boolean>,
  ): Int = update(`where`, limit) {
    val ignoreColumns = ignore ?: arrayOf()
    assign(it, raw, selective = selective, *ignoreColumns)
  }

  public fun OAuth2ClientTable.selectMany(vararg selective: Column<*>, `where`: Query.() -> Query?):
      List<OAuth2Client> {
    val query = selectSlice(*selective)
    `where`.invoke(query)
    return query.toOAuth2ClientList(*selective)
  }

  public fun OAuth2ClientTable.selectOne(vararg selective: Column<*>, `where`: Query.() -> Query?):
      OAuth2Client? {
    val query = selectSlice(*selective)
    `where`.invoke(query)
    return query.firstOrNull()?.toOAuth2Client(*selective)
  }

  public fun OAuth2ClientTable.replace(raw: OAuth2Client): ReplaceStatement<Long> = replace {
    assign(it, raw)
  }
}
